LEADMQR - АРХИТЕКТУРА С БРАУЗЕР-ПУЛОМ
========================================

ОБЩАЯ АРХИТЕКТУРА
=================

Система состоит из двух основных сервисов:

1. LEAD PROCESSING SERVICE
   - Мониторинг новых лидов на Thumbtack
   - Обработка лидов (извлечение телефонов)
   - Интеграция с Jobber
   - Отправка задач в Browser Pool Service

2. BROWSER POOL SERVICE
   - Управление пулом браузеров (3 браузера)
   - Создание/закрытие вкладок
   - Изоляция сессий между аккаунтами
   - Обработка запросов от Lead Processing Service

ОБЩЕНИЕ МЕЖДУ СЕРВИСАМИ
========================

Используется Celery + RabbitMQ для асинхронного общения:

- Lead Processing Service отправляет задачи в Browser Pool Service
- Browser Pool Service возвращает результаты через Celery
- Все общение происходит через RabbitMQ брокер
- Обеспечивает надежность и масштабируемость

ПРИНЦИП РАБОТЫ С АККАУНТАМИ
===========================

Один аккаунт = один браузер + множество вкладок для этого аккаунта:

Browser 1 (Account A):
├── Вкладка 1 (Lead 1)
├── Вкладка 2 (Lead 2)
└── Вкладка 3 (Lead 3)

Browser 2 (Account B):
├── Вкладка 1 (Lead 4)
└── Вкладка 2 (Lead 5)

Browser 3 (Account C):
└── Вкладка 1 (Lead 6)

КЛЮЧЕВЫЕ ПРИНЦИПЫ
=================

1. ИЗОЛЯЦИЯ АККАУНТОВ
   - Account A всегда в Browser 1
   - Account B всегда в Browser 2
   - Account C всегда в Browser 3
   - Сессии не смешиваются между аккаунтами

2. ПЕРЕИСПОЛЬЗОВАНИЕ БРАУЗЕРОВ
   - 3 браузера работают постоянно
   - Вкладки создаются/закрываются по мере необходимости
   - Браузеры не перезапускаются между задачами

3. МАСШТАБИРУЕМОСТЬ
   - Легко добавлять новые аккаунты
   - Каждый аккаунт может обрабатывать множество лидов одновременно
   - Можно увеличить пул браузеров при росте нагрузки

ПОТОК ДАННЫХ
============

1. Lead Producer находит новый лид на Thumbtack
2. Lead Producer отправляет задачу в Lead Processing Service
3. Lead Processing Service запрашивает браузер у Browser Pool Service
4. Browser Pool Service возвращает browser_id
5. Lead Processing Service создает вкладку в указанном браузере
6. Lead Processing Service извлекает телефон из вкладки
7. Lead Processing Service отправляет лид в Jobber
8. Lead Processing Service закрывает вкладку
9. Browser Pool Service освобождает браузер для новых задач

CELERY ЗАДАЧИ
=============

LEAD PROCESSING SERVICE:
- process_lead_task(lead_data) - основная задача обработки лида
- extract_phone_from_page(page_id, lead_url, account_id) - извлечение телефона
- send_lead_to_jobber(lead_data, phone) - отправка в Jobber

BROWSER POOL SERVICE:
- get_browser() - получение свободного браузера
- create_page_for_account(browser_id, page_id, account_id) - создание вкладки
- extract_phone_from_page(page_id, lead_url, account_id) - извлечение данных
- close_page(page_id) - закрытие вкладки

DOCKER COMPOSE СТРУКТУРА
========================

services:
  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "5672:5672"
      - "15672:15672"
  
  browser-pool:
    build: .
    command: celery -A browser_pool worker --loglevel=info
    depends_on:
      - rabbitmq
    environment:
      - CELERY_BROKER_URL=amqp://rabbitmq:5672
  
  lead-processor:
    build: .
    command: celery -A leadmqr worker --loglevel=info
    depends_on:
      - rabbitmq
    environment:
      - CELERY_BROKER_URL=amqp://rabbitmq:5672
  
  flower:
    build: .
    ports:
      - "5555:5555"
    depends_on:
      - rabbitmq

ПРЕИМУЩЕСТВА АРХИТЕКТУРЫ
========================

1. ЭКОНОМИЯ РЕСУРСОВ
   - 3 браузера вместо N воркеров
   - Экономия памяти: 70-90%
   - Экономия CPU: 60-80%

2. НАДЕЖНОСТЬ
   - Celery обеспечивает гарантированную доставку сообщений
   - Автоматическое восстановление при сбоях
   - Изоляция между аккаунтами

3. МАСШТАБИРУЕМОСТЬ
   - Легко добавлять новые аккаунты
   - Можно увеличить пул браузеров
   - Независимое масштабирование сервисов

4. МОНИТОРИНГ
   - Flower для мониторинга Celery задач
   - Централизованное логирование
   - Метрики производительности

ПЛАН РЕАЛИЗАЦИИ
===============

ЭТАП 1: Создание Browser Pool Service
- Создать browser_pool/ директорию
- Написать Celery задачи для управления браузерами
- Добавить в docker-compose

ЭТАП 2: Модификация Lead Processing
- Изменить leads/tasks.py для работы с Browser Pool
- Убрать создание браузеров из LeadRunner
- Добавить вызовы Browser Pool задач

ЭТАП 3: Тестирование
- Протестировать с 1-3 аккаунтами
- Проверить изоляцию между аккаунтами
- Протестировать масштабирование

ЭТАП 4: Деплой в продакшен
- Настроить мониторинг
- Добавить обработку ошибок
- Настроить автоматическое восстановление

ПОТЕНЦИАЛЬНЫЕ ПРОБЛЕМЫ И РЕШЕНИЯ
=================================

1. ПРОБЛЕМА: Браузер-сервис падает
   РЕШЕНИЕ: Автоматический restart, health checks, мониторинг

2. ПРОБЛЕМА: Нехватка браузеров
   РЕШЕНИЕ: Увеличение пула, очередь задач, приоритизация

3. ПРОБЛЕМА: Сетевые задержки
   РЕШЕНИЕ: Retry логика, таймауты, локальный кэш

4. ПРОБЛЕМА: Memory leaks
   РЕШЕНИЕ: Мониторинг памяти, автоматическая очистка, лимиты

КРИТЕРИИ ГОТОВНОСТИ К ПРОДАКШЕНУ
================================

ФУНКЦИОНАЛЬНОСТЬ:
- Все тесты проходят
- Стабильная работа 24/7
- Обработка всех типов ошибок
- Graceful shutdown

ПРОИЗВОДИТЕЛЬНОСТЬ:
- Время отклика API < 100ms
- Обработка 100+ лидов в час
- Использование памяти < 80%
- CPU usage < 70%

НАДЕЖНОСТЬ:
- Uptime > 99.5%
- Автоматическое восстановление
- Мониторинг и алерты
- Backup стратегия

ВРЕМЕННЫЕ РАМКИ
===============

- Разработка: 2-3 недели
- Тестирование: 1-2 недели
- Деплой: 1 неделя
- Стабилизация: 1-2 недели

ИТОГО: 5-8 недель до полного продакшена

ЗАКЛЮЧЕНИЕ
==========

Данная архитектура обеспечивает оптимальный баланс между:
- Простотой реализации
- Эффективностью использования ресурсов
- Масштабируемостью
- Надежностью

Система готова к масштабированию на множество аккаунтов
и обеспечивает стабильную обработку лидов с минимальным
потреблением ресурсов.
